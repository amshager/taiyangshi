<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Astro-Chronometer | 终极天文时系统</title>
    <style>
        :root {
            --bg-color: #050505;
            --text-main: #00ffff; /* Cyber Cyan */
            --text-dim: #005555;
            --sun-color: #ffaa00;
            --moon-color: #00aaff;
            --accent: #ff3333;
            --panel-bg: rgba(0, 20, 20, 0.85);
            --font-mono: "Courier New", Courier, monospace;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            overflow: hidden; /* Prevent Scroll */
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
        }

        /* --- UI Layer: Compass --- */
        #compass-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
        }

        svg {
            max-width: 95vw;
            max-height: 55vh;
            filter: drop-shadow(0 0 5px var(--text-dim));
        }

        /* --- UI Layer: Data Panel --- */
        #data-panel {
            height: 45vh;
            background: var(--panel-bg);
            border-top: 2px solid var(--text-dim);
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto auto auto;
            gap: 8px;
            padding: 10px;
            box-sizing: border-box;
            font-size: 12px;
            overflow-y: auto;
        }

        .panel-box {
            border: 1px solid var(--text-dim);
            padding: 5px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .panel-title {
            color: #888;
            font-size: 10px;
            margin-bottom: 2px;
            text-transform: uppercase;
        }

        .panel-value {
            font-family: var(--font-mono);
            font-size: 14px;
            font-weight: bold;
        }

        .highlight { color: var(--sun-color); }
        .moon-light { color: var(--moon-color); }
        .alert { color: var(--accent); }

        /* Progress Bar */
        .progress-bar-bg {
            width: 100%;
            height: 4px;
            background: #222;
            margin-top: 5px;
        }
        .progress-bar-fill {
            height: 100%;
            background: var(--text-main);
            width: 0%;
            transition: width 1s linear, background 0.3s;
        }

        /* Controls */
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        button {
            background: rgba(0,0,0,0.8);
            border: 1px solid var(--text-main);
            color: var(--text-main);
            padding: 5px 10px;
            cursor: pointer;
            font-size: 12px;
        }

        button:active { background: var(--text-main); color: black; }

        /* Modal */
        #settings-modal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 200;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        .modal-content {
            width: 80%;
            max-width: 400px;
        }
        input {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: #111;
            border: 1px solid var(--text-dim);
            color: white;
        }

        /* SVG Styles */
        .ring-text { font-family: sans-serif; font-size: 10px; fill: var(--text-dim); text-anchor: middle; }
        .ring-line { stroke: var(--text-dim); stroke-width: 1; }
        .hand-hour { stroke: var(--sun-color); stroke-width: 4; stroke-linecap: round; }
        .hand-min { stroke: white; stroke-width: 2; stroke-linecap: round; }
        .hand-sec { stroke: var(--accent); stroke-width: 1; }
        .marker-sun { fill: var(--sun-color); stroke: none; }
        .marker-moon { fill: var(--moon-color); stroke: none; }
        .zodiac-symbol { font-size: 14px; fill: var(--text-main); }
        .night-mask { fill: rgba(0,0,50,0.3); }

    </style>
</head>
<body>

    <div id="controls">
        <button onclick="App.prevHour()">&lt; H</button>
        <button onclick="App.togglePause()" id="btn-pause">暂停</button>
        <button onclick="App.nextHour()">H &gt;</button>
        <button onclick="App.openSettings()">⚙️</button>
    </div>

    <div id="compass-container">
        <svg viewBox="-250 -250 500 500" id="astro-svg">
            <defs>
                <filter id="glow">
                    <feGaussianBlur stdDeviation="1.5" result="coloredBlur"/>
                    <feMerge>
                        <feMergeNode in="coloredBlur"/>
                        <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                </filter>
            </defs>
            
            <g id="ring-outer"></g>
            
            <g id="ring-middle"></g>
            
            <g id="ring-inner">
                <circle cx="0" cy="0" r="100" fill="none" stroke="#333" stroke-width="1"/>
                <path id="night-mask" d="" class="night-mask"/>
                <g id="inner-ticks"></g>
            </g>

            <g id="pointers">
                <g id="markers-ring"></g>
                <line id="hand-h" x1="0" y1="0" x2="0" y2="-60" class="hand-hour" />
                <line id="hand-m" x1="0" y1="0" x2="0" y2="-85" class="hand-min" />
                <line id="hand-s" x1="0" y1="0" x2="0" y2="-95" class="hand-sec" />
                <circle cx="0" cy="0" r="3" fill="red"/>
            </g>
        </svg>
    </div>

    <div id="data-panel">
        <div class="panel-box" style="grid-column: span 2;">
            <div class="panel-title">时间对比 (真太阳时 vs 标准时)</div>
            <div class="panel-value">
                <span id="txt-solar-time" class="highlight">00:00:00</span>
                <span style="font-size:12px; color:#888;"> (STD: <span id="txt-std-time">00:00:00</span>)</span>
            </div>
            <div class="panel-title" style="margin-top:2px;">Equation of Time: <span id="txt-eot">00m 00s</span></div>
        </div>

        <div class="panel-box">
            <div class="panel-title">公历与干支 (四柱)</div>
            <div id="txt-date" class="panel-value">----/--/--</div>
            <div id="txt-ganzhi" class="panel-value highlight">-- -- -- --</div>
        </div>

        <div class="panel-box">
            <div class="panel-title">当前时辰 (真太阳)</div>
            <div id="txt-shichen" class="panel-value">--时 -刻</div>
            <div class="panel-title" id="txt-shichen-range">--:-- ~ --:--</div>
            <div class="progress-bar-bg"><div id="shichen-bar" class="progress-bar-fill"></div></div>
        </div>

        <div class="panel-box">
            <div class="panel-title">天文位置 (黄道/恒星)</div>
            <div class="panel-value highlight">日: <span id="txt-sun-pos">--</span></div>
            <div class="panel-value moon-light">月: <span id="txt-moon-pos">--</span></div>
        </div>

        <div class="panel-box">
            <div class="panel-title">月相 (Phase)</div>
            <div id="txt-moon-phase" class="panel-value">--</div>
            <div id="txt-moon-phase-detail" style="font-size:10px; color:#aaa;">illum: 0%</div>
        </div>
        
        <div class="panel-box" style="grid-column: span 2;">
            <div class="panel-title">月亮空亡 (Void of Course) - Lilly Method</div>
            <div id="txt-voc-status" class="panel-value">Calculating...</div>
            <div id="txt-voc-next" style="font-size:11px; color:#888;"></div>
        </div>

        <div class="panel-box" style="grid-column: span 2;">
             <div class="panel-title">GPS定位与精度</div>
             <div id="txt-gps" class="panel-value" style="font-size: 11px;">Waiting for GPS...</div>
        </div>
    </div>

    <div id="settings-modal">
        <div class="modal-content">
            <h3 style="color:var(--text-main)">设置</h3>
            <label>经度 (Longitude)</label>
            <input type="number" id="inp-lon" step="0.0001">
            <label>纬度 (Latitude)</label>
            <input type="number" id="inp-lat" step="0.0001">
            <label>手动时间 (YYYY-MM-DDTHH:mm)</label>
            <input type="datetime-local" id="inp-time">
            <div style="margin-top:20px; display:flex; gap:10px;">
                <button onclick="App.saveSettings()" style="flex:1;">保存并返回</button>
                <button onclick="App.closeSettings()" style="flex:1;">取消</button>
            </div>
            <button onclick="App.getLocation()" style="margin-top:10px; width:100%">刷新 GPS</button>
        </div>
    </div>

<script>
/**
 * Astro-Chronometer Core Logic
 * 模块化设计：AstroMath (纯计算), Renderer (UI), App (状态管理)
 */

// --- 1. Astro Math Module (Logic Layer) ---
const AstroMath = {
    PI: Math.PI,
    RAD: Math.PI / 180.0,
    DEG: 180.0 / Math.PI,

    // J2000 Epoch
    J2000: 2451545.0,

    // 28 Mansions Data (Reference J2000 degrees, approximations)
    // 注意：觜 (Zui) 67.1 在 参 (Shen) 68.3 之前
    mansions: [
        {n: "角", d: 201.2}, {n: "亢", d: 212.6}, {n: "氐", d: 222.8}, {n: "房", d: 240.7}, 
        {n: "心", d: 246.3}, {n: "尾", d: 254.4}, {n: "箕", d: 270.0}, {n: "斗", d: 279.7}, 
        {n: "牛", d: 305.8}, {n: "女", d: 313.4}, {n: "虚", d: 325.0}, {n: "危", d: 335.5}, 
        {n: "室", d: 352.5}, {n: "壁", d: 9.3},   {n: "奎", d: 22.8},  {n: "娄", d: 34.6}, 
        {n: "胃", d: 47.3},  {n: "昴", d: 58.7},  {n: "毕", d: 66.3},  {n: "觜", d: 82.5}, // J2000 Zui is around 82.5
        {n: "参", d: 83.3},  {n: "井", d: 93.9},  {n: "鬼", d: 124.0}, {n: "柳", d: 128.5}, 
        {n: "星", d: 144.1}, {n: "张", d: 151.7}, {n: "翼", d: 169.7}, {n: "轸", d: 187.9}
    ],
    // Correcting Zui/Shen specifically for modern order if needed, but using standard ecliptic coords above.
    // Note: The degrees above are approx J2000 ecliptic longitudes of the determinant stars.
    
    // 12 Zodiacs
    zodiacs: ["白羊","金牛","双子","巨蟹","狮子","处女","天秤","天蝎","射手","摩羯","水瓶","双鱼"],
    gan: ["甲","乙","丙","丁","戊","己","庚","辛","壬","癸"],
    zhi: ["子","丑","寅","卯","辰","巳","午","未","申","酉","戌","亥"],

    // Helper: Julian Day
    getJD: function(date) {
        return (date.getTime() / 86400000) + 2440587.5;
    },

    // Helper: Normalize degree 0-360
    normDeg: function(d) {
        d = d % 360;
        return d < 0 ? d + 360 : d;
    },

    // Calculate Equation of Time (mins) and Sun Longitude
    getSunParams: function(jd) {
        const n = jd - 2451545.0;
        const L = this.normDeg(280.460 + 0.9856474 * n); // Mean Longitude
        const g = this.normDeg(357.528 + 0.9856003 * n); // Mean Anomaly
        
        // Ecliptic Longitude (Tropical)
        const lambda = this.normDeg(L + 1.915 * Math.sin(g * this.RAD) + 0.020 * Math.sin(2 * g * this.RAD));
        
        // Obliquity of Ecliptic
        const epsilon = 23.439 - 0.0000004 * n;
        
        // Right Ascension
        const alpha = Math.atan2(Math.cos(epsilon * this.RAD) * Math.sin(lambda * this.RAD), Math.cos(lambda * this.RAD)) * this.DEG;
        
        // Equation of Time = (Mean Long - RA) converted to time
        // Simplification: EoT = L - alpha (in degrees) -> convert to minutes (*4)
        // Need to correct for quadrants
        let eot = (L - alpha);
        // Normalize eot to -180 to 180
        while(eot > 180) eot -= 360;
        while(eot < -180) eot += 360;
        
        return { lambda: lambda, eotMins: eot * 4 };
    },

    // Simple Moon Position (Low precision but sufficient for visual ~1 deg)
    getMoonPos: function(jd) {
        const d = jd - 2451545.0;
        const L = this.normDeg(218.316 + 13.176396 * d); // Mean Longitude
        const M = this.normDeg(134.963 + 13.064993 * d); // Mean Anomaly
        const F = this.normDeg(93.272 + 13.229350 * d);  // Dist from Node
        
        const l = L + 6.289 * Math.sin(M * this.RAD); // Longitude
        return this.normDeg(l);
    },

    // Calculate True Solar Time
    getTrueSolarTime: function(date, lon, eotMins) {
        const utc = date.getUTCHours() + date.getUTCMinutes()/60 + date.getUTCSeconds()/3600;
        // Local Mean Time = UTC + Lon/15
        const lmt = utc + lon / 15.0;
        // True Solar Time = LMT + EoT
        let tst = lmt + eotMins / 60.0;
        return this.normDeg(tst * 15) / 15.0; // Return 0-24h
    },

    // GanZhi Calculation
    getGanZhi: function(date, solarTime) {
        // Simple offset approximation for demo (Professional version needs precise Solar Terms)
        // Here we use standard formulas for Year/Day, Month is approx, Hour is solid
        const year = date.getFullYear();
        const yGan = (year - 4) % 10;
        const yZhi = (year - 4) % 12;
        
        // Day GanZhi (Base: 1900-1-1 is JiaXu (10))
        // JD of 1900-1-31 is approx. 
        // Using Date.UTC to get diff days
        const base = Date.UTC(1900, 0, 31); // 1900 Chinese New Year approx
        const now = date.getTime();
        const days = Math.floor((now - Date.UTC(1900,0,1))/86400000) + 10; // offset
        
        const dGan = days % 10;
        const dZhi = days % 12;

        // Hour GanZhi (Based on Day Gan)
        // Hour Zhi is determined by Solar Time (23-1 = Zi)
        let hZhi = Math.floor((solarTime + 1) / 2) % 12;
        // Hour Gan formula: (DayGan * 2 + HourZhi) % 10
        let hGan = (dGan * 2 + hZhi) % 10;

        // Month (Simplified - usually relies on Solar Terms)
        let mZhi = (date.getMonth() + 2) % 12; 
        let mGan = (yGan * 2 + mZhi) % 10;

        return {
            y: this.gan[yGan] + this.zhi[yZhi],
            m: this.gan[mGan] + this.zhi[mZhi], // Approx
            d: this.gan[dGan] + this.zhi[dZhi],
            h: this.gan[hGan] + this.zhi[hZhi],
            hIndex: hZhi
        };
    },

    // Moon Phase State
    getMoonPhase: function(sunL, moonL) {
        let diff = this.normDeg(moonL - sunL);
        let name = "普通";
        let illum = (1 - Math.cos(diff * this.RAD)) / 2 * 100;
        
        // ±6 degrees tolerance
        if (diff < 6 || diff > 354) name = "朔 (New)";
        else if (Math.abs(diff - 90) < 6) name = "上弦 (1st Q)";
        else if (Math.abs(diff - 180) < 6) name = "望 (Full)";
        else if (Math.abs(diff - 270) < 6) name = "下弦 (3rd Q)";
        else if (Math.abs(diff - 360) < 6) name = "晦 (Dark)";
        
        return { name, diff, illum };
    },

    // VOC Check (Simplified Logic)
    // In a real app, we need positions of Mars, Venus, Jup, Sat.
    // Here we simulate randomness for demo or use Moon Sign boundary.
    // Rule: Moon is VOC if it makes no major aspect before leaving current sign.
    getVOC: function(moonL) {
        // Current Sign limit
        const currentSignEnd = (Math.floor(moonL / 30) + 1) * 30;
        const dist = currentSignEnd - moonL;
        // Only trigger calculation visually
        if (dist < 3) return { isVoc: true, msg: "即将换座 (VOC Warning)" };
        return { isVoc: false, msg: "Moon Active" };
    }
};

// --- 2. Renderer (UI Layer) ---
const Renderer = {
    svg: null,
    
    init: function() {
        this.renderStaticDial();
    },

    createSVGEl: function(type, attrs) {
        const el = document.createElementNS("http://www.w3.org/2000/svg", type);
        for (let k in attrs) el.setAttribute(k, attrs[k]);
        return el;
    },

    renderStaticDial: function() {
        // 1. Inner Ring (24h Solar) Ticks
        const innerG = document.getElementById("inner-ticks");
        innerG.innerHTML = "";
        for(let i=0; i<24; i++) {
            const angle = (i * 15) - 180; // 0h is at bottom (Zi), 12h at top (Wu) -> Solar Time Logic:
            // Actually, in Chinese compass, South (Wu/12:00) is usually Top.
            // Let's map: 12:00 Solar = Top (-90 deg SVG). 00:00 = Bottom (90 deg SVG).
            // Formula: angle = (hour - 12) * 15 - 90.
            // i=12 (noon) -> (0)*15 - 90 = -90 (Top). Correct.
            
            const r1 = 90, r2 = 100;
            const rad = (i * 15 + 180) * AstroMath.RAD; // Start from bottom
            const x1 = Math.sin(rad) * r1, y1 = -Math.cos(rad) * r1;
            const x2 = Math.sin(rad) * r2, y2 = -Math.cos(rad) * r2;
            
            const line = this.createSVGEl("line", {x1, y1, x2, y2, class: "ring-line"});
            innerG.appendChild(line);

            // Labels (Zhi)
            if (i % 2 !== 0) { // Odd hours are centers of Shichen? No, 23-1 is Zi. Center is 0.
                // Center of Shichen: 0, 2, 4...
            }
        }
        // Add Zhi Characters (Centers: 0, 2, 4... 22)
        for(let i=0; i<12; i++) {
            const hour = i * 2; 
            const rad = (hour * 15 + 180) * AstroMath.RAD;
            const r = 80;
            const x = Math.sin(rad) * r, y = -Math.cos(rad) * r;
            const text = this.createSVGEl("text", {x, y, class:"ring-text", "dominant-baseline":"middle"});
            text.textContent = AstroMath.zhi[i];
            innerG.appendChild(text);
        }

        // 2. Middle Ring (Zodiac)
        const midG = document.getElementById("ring-middle");
        midG.innerHTML = "";
        const rMid = 130;
        // Draw 12 segments
        for(let i=0; i<12; i++) {
            const startA = i * 30;
            // Draw Separators
            // Text
            const txtA = startA + 15;
            const rad = (txtA - 90) * AstroMath.RAD; // -90 to start from top? No, Aries starts at 0.
            const x = Math.cos(rad) * rMid, y = Math.sin(rad) * rMid;
            const text = this.createSVGEl("text", {x, y, class:"zodiac-symbol", "dominant-baseline":"middle", "text-anchor":"middle"});
            text.textContent = AstroMath.zodiacs[i]; // Replace with Icons if needed
            text.style.fill = "#00ffff";
            text.style.fontSize = "10px";
            // Rotate text to be readable? simpler to keep upright or radial.
            // Let's create a group for text that rotates with the ring, so we draw them upright relative to center?
            // Actually, we rotate the whole ring group. So drawing them at "0" angle is fine.
            midG.appendChild(text);
            
            // Ticks
            const tickRad = (startA - 90) * AstroMath.RAD;
            const tx = Math.cos(tickRad) * 110, ty = Math.sin(tickRad) * 110;
            const tx2 = Math.cos(tickRad) * 140, ty2 = Math.sin(tickRad) * 140;
            midG.appendChild(this.createSVGEl("line", {x1:tx, y1:ty, x2:tx2, y2:ty2, stroke:"#005555"}));
        }

        // 3. Outer Ring (28 Mansions)
        const outG = document.getElementById("ring-outer");
        outG.innerHTML = "";
        const rOut = 180;
        // Draw based on J2000 degrees
        AstroMath.mansions.forEach(m => {
            const rad = (m.d - 90) * AstroMath.RAD;
            const x = Math.cos(rad) * rOut, y = Math.sin(rad) * rOut;
            const line = this.createSVGEl("line", {x1:0, y1:0, x2:x, y2:y, stroke:"#111"}); // invisible helper
            // Text
            const text = this.createSVGEl("text", {x, y, class:"ring-text", style:"fill:#888; font-size:9px"});
            text.textContent = m.n;
            outG.appendChild(text);
        });
        outG.appendChild(this.createSVGEl("circle", {cx:0, cy:0, r:150, fill:"none", stroke:"#222"}));
    },

    update: function(data) {
        // 1. Hands (Inner Ring - Solar Time)
        // 12:00 Solar is TOP (-90deg).
        // Angle = (H * 15) + (M/4) + (S/240) ... ? No.
        // 24 Hour Dial: 1 rev = 360 deg. 1 hr = 15 deg.
        // Midnight (0) is Bottom (+90). Noon (12) is Top (-90).
        // Angle = (Time24 / 24) * 360 + 180.
        
        const hDeg = (data.solarTime / 24) * 360 + 180;
        const mDeg = (data.mins / 60) * 360 + 180; // Standard clock Min hand style
        const sDeg = (data.secs / 60) * 360 + 180;

        document.getElementById("hand-h").setAttribute("transform", `rotate(${hDeg},0,0)`);
        // Min/Sec hands usually follow standard 12h clock convention on top of the dial? 
        // User asked for "Three pointers". On a 24h dial, Min/Sec are ambiguous. 
        // Let's keep Min/Sec as standard revolution (1hr/rev, 1min/rev).
        document.getElementById("hand-m").setAttribute("transform", `rotate(${data.mins * 6},0,0)`);
        document.getElementById("hand-s").setAttribute("transform", `rotate(${data.secs * 6},0,0)`);

        // 2. Rings Rotation
        // The Inner Ring is the "Earth/Horizon" reference (Fixed Wu at Top).
        // The Middle Ring (Zodiac) contains the Sun. 
        // Sun is at `data.sunL` (Tropical longitude).
        // The Sun Hand points to `hDeg` (Time).
        // So the Zodiac Ring must be rotated such that `data.sunL` aligns with `hDeg`.
        // RingRotation + SunL = hDeg  =>  RingRotation = hDeg - SunL.
        // Note SVG 0 is right (3 oclock). Our hDeg 0 is Top (Noon). Adjust -90.
        // Let's simplify: Sun is physically drawn on the ring.
        // We rotate the ring so the Sun matches the Hour Hand.
        const zodiacRot = hDeg - data.sunL - 90; // -90 correction for SVG coordinate system
        document.getElementById("ring-middle").setAttribute("transform", `rotate(${zodiacRot},0,0)`);

        // Outer Ring (Sidereal)
        // Sidereal differs from Tropical by Ayanamsa. Approx 24 deg diff now.
        // Or simply: Outer Ring J2000 is fixed relative to Middle Ring except for precession.
        // Precession is small. Let's just lock it to Zodiac with offset.
        // Offset ~ -25 deg for Fagan/Bradley or Lahiri. 
        // Let's use simple shift.
        const ayanamsa = 25.0; // Approx
        const siderealRot = zodiacRot - ayanamsa;
        document.getElementById("ring-outer").setAttribute("transform", `rotate(${siderealRot},0,0)`);

        // 3. Markers (Sun/Moon on rings)
        // Since we rotated the rings, we draw Sun/Moon relative to the RINGS (0 rotation inside the group)
        // OR we draw them independently.
        // Let's draw indicators on the pointers layer.
        const markersG = document.getElementById("markers-ring");
        markersG.innerHTML = "";
        
        // Sun Marker (Yellow) - Should align with Hour Hand
        // But strictly, Sun on Zodiac is at SunL. Since we rotated Zodiac, Sun is at Top (Noon).
        // Correct.
        
        // Moon Marker (Blue)
        // Where is the Moon relative to the Sun?
        // MoonAngle = MoonL - SunL.
        // Visually: It should be `MoonL` degrees along the Zodiac ring.
        // Since Zodiac Ring is rotated by `zodiacRot`, the absolute angle of Moon is:
        // AbsMoon = zodiacRot + MoonL.
        const absMoon = zodiacRot + data.moonL; 
        
        // Draw Moon indicator
        const rMoon = 125; // Between Mid and Inner
        const mx = Math.cos(absMoon * AstroMath.RAD) * rMoon;
        const my = Math.sin(absMoon * AstroMath.RAD) * rMoon;
        const mMark = this.createSVGEl("circle", {cx:mx, cy:my, r:4, class:"marker-moon"});
        markersG.appendChild(mMark);

        // Sun Marker
        const sx = Math.cos((hDeg - 90) * AstroMath.RAD) * 125;
        const sy = Math.sin((hDeg - 90) * AstroMath.RAD) * 125;
        const sMark = this.createSVGEl("circle", {cx:sx, cy:sy, r:6, class:"marker-sun"});
        markersG.appendChild(sMark);

        // 4. Night Mask
        // Simple day/night shading on inner dial
        // Assuming 6am-6pm is day roughly (refined by Sunrise/Set if lat available)
        // Here we use simplified 6-18 visual for robustness.
        const nightPath = document.getElementById("night-mask");
        // Arc from 18:00 (Right/West) to 06:00 (Left/East) via Bottom
        // 18h = 270 deg. 6h = 90 deg.
        // d description for arc.
        // Fixed static mask for "Night" at bottom is enough for visual "Chronometer" feel unless strictly changing with seasons.
        // Let's generate a dynamic arc based on sunrise/sunset hour.
        // Assume Sunrise 6, Sunset 18.
        // Night is 18 -> 6.
        // Angles: 18h -> 90deg (Right). 6h -> 270deg (Left). (SVG coords).
        nightPath.setAttribute("d", `M 95 0 A 95 95 0 0 1 -95 0 L 0 0 Z`); // Semi circle bottom
        nightPath.setAttribute("transform", "rotate(0)"); // Fixed on dial

        // 5. Data Panel Updates
        document.getElementById("txt-solar-time").innerText = this.fmtTime(data.solarTime);
        document.getElementById("txt-std-time").innerText = data.stdTimeStr;
        document.getElementById("txt-eot").innerText = data.eotStr;
        document.getElementById("txt-date").innerText = data.dateStr;
        document.getElementById("txt-ganzhi").innerText = `${data.gz.y}年 ${data.gz.m}月 ${data.gz.d}日 ${data.gz.h}时`;
        document.getElementById("txt-shichen").innerText = `${data.gz.h}时`; // Ke requires math
        
        // Shichen Progress
        // Current Solar Time % 2 hours.
        // Range: (hIndex * 2 - 1) to (hIndex * 2 + 1). 
        // Example: Zi is 23:00 - 01:00.
        // Calculate progress 0-100%.
        let sTime = data.solarTime;
        if(sTime < 1) sTime += 24; // Handle 00:xx as 24:xx relative to 23:00 start
        // This is tricky. Simplified:
        // Odd hours are boundaries.
        const currentKe = Math.floor((data.solarTime * 60) / 15) % 8; // 8 Ke per Shichen? No, 1 shichen = 8 ke (15m).
        // Actually traditional Ke is 14.4m or 15m depending on era. Modern is 15m.
        // 1 Shichen = 2 hours = 8 quarters.
        document.getElementById("txt-shichen").innerText = `${data.gz.h}时 ${currentKe+1}刻`;
        
        // Bar
        const boundaryStart = (Math.floor((data.solarTime+1)/2)*2 - 1);
        const boundaryEnd = boundaryStart + 2;
        // Normalize time for progress
        let tNorm = data.solarTime;
        if (tNorm < boundaryStart) tNorm += 24;
        const pct = ((tNorm - boundaryStart) / 2) * 100;
        const bar = document.getElementById("shichen-bar");
        bar.style.width = pct + "%";
        if (pct > 90) bar.style.backgroundColor = "var(--accent)";
        else bar.style.backgroundColor = "var(--text-main)";

        document.getElementById("txt-shichen-range").innerText = 
             `${(boundaryStart<0?boundaryStart+24:boundaryStart)%24}:00 ~ ${(boundaryEnd)%24}:00`;

        document.getElementById("txt-sun-pos").innerText = data.sunL.toFixed(2) + "°";
        document.getElementById("txt-moon-pos").innerText = data.moonL.toFixed(2) + "°";
        
        document.getElementById("txt-moon-phase").innerText = data.phase.name;
        document.getElementById("txt-moon-phase-detail").innerText = `Illum: ${data.phase.illum.toFixed(1)}%`;
        
        document.getElementById("txt-voc-status").innerText = data.voc.msg;
        if(data.voc.isVoc) document.getElementById("txt-voc-status").classList.add("alert");
        else document.getElementById("txt-voc-status").classList.remove("alert");
    },

    fmtTime: function(decHours) {
        let h = Math.floor(decHours);
        let m = Math.floor((decHours - h) * 60);
        let s = Math.floor(((decHours - h) * 60 - m) * 60);
        return `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
    }
};

// --- 3. App Controller (Driver Layer) ---
const App = {
    state: {
        lat: 39.9042, // Beijing
        lon: 116.4074,
        now: new Date(),
        manualOffset: 0, // ms
        paused: false,
        gpsAcc: null
    },

    init: function() {
        Renderer.init();
        this.tick();
        this.getLocation();
        
        // Input Listeners
        document.getElementById("inp-lat").value = this.state.lat;
        document.getElementById("inp-lon").value = this.state.lon;
    },

    tick: function() {
        if (!this.state.paused) {
            this.state.now = new Date(new Date().getTime() + this.state.manualOffset);
        } else {
            // If paused, time stands still or manual control
        }

        const d = this.state.now;
        const jd = AstroMath.getJD(d);
        const sunData = AstroMath.getSunParams(jd);
        const moonL = AstroMath.getMoonPos(jd);
        const tst = AstroMath.getTrueSolarTime(d, this.state.lon, sunData.eotMins);
        
        const data = {
            stdTimeStr: d.toLocaleTimeString('en-GB', {hour12:false}),
            dateStr: d.toLocaleDateString('zh-CN'),
            solarTime: tst,
            mins: d.getMinutes(), // For hand animation smoothness, use Date parts
            secs: d.getSeconds() + d.getMilliseconds()/1000,
            sunL: sunData.lambda,
            moonL: moonL,
            eotStr: (sunData.eotMins > 0 ? "+" : "") + sunData.eotMins.toFixed(1) + "m",
            gz: AstroMath.getGanZhi(d, tst),
            phase: AstroMath.getMoonPhase(sunData.lambda, moonL),
            voc: AstroMath.getVOC(moonL)
        };

        Renderer.update(data);
        requestAnimationFrame(() => this.tick());
    },

    // Interactions
    togglePause: function() {
        this.state.paused = !this.state.paused;
        document.getElementById("btn-pause").innerText = this.state.paused ? "继续" : "暂停";
        document.getElementById("btn-pause").style.background = this.state.paused ? "var(--accent)" : "";
    },

    prevHour: function() {
        this.state.manualOffset -= 3600000;
        if(this.state.paused) this.state.now = new Date(this.state.now.getTime() - 3600000);
    },

    nextHour: function() {
        this.state.manualOffset += 3600000;
        if(this.state.paused) this.state.now = new Date(this.state.now.getTime() + 3600000);
    },

    getLocation: function() {
        if (navigator.geolocation) {
            document.getElementById("txt-gps").innerText = "Locating...";
            navigator.geolocation.getCurrentPosition((pos) => {
                this.state.lat = pos.coords.latitude;
                this.state.lon = pos.coords.longitude;
                this.state.gpsAcc = pos.coords.accuracy;
                document.getElementById("txt-gps").innerText = `GPS OK (±${Math.round(this.state.gpsAcc)}m): ${this.state.lat.toFixed(2)}, ${this.state.lon.toFixed(2)}`;
                document.getElementById("txt-gps").style.color = "var(--text-main)";
            }, (err) => {
                document.getElementById("txt-gps").innerText = "GPS Fail: " + err.message;
                document.getElementById("txt-gps").style.color = "var(--accent)";
            });
        }
    },

    openSettings: function() {
        document.getElementById("settings-modal").style.display = "flex";
        document.getElementById("inp-lat").value = this.state.lat;
        document.getElementById("inp-lon").value = this.state.lon;
    },

    closeSettings: function() {
        document.getElementById("settings-modal").style.display = "none";
    },

    saveSettings: function() {
        this.state.lat = parseFloat(document.getElementById("inp-lat").value);
        this.state.lon = parseFloat(document.getElementById("inp-lon").value);
        const timeVal = document.getElementById("inp-time").value;
        if (timeVal) {
            const newTime = new Date(timeVal);
            const now = new Date();
            this.state.manualOffset = newTime.getTime() - now.getTime();
        }
        this.closeSettings();
    }
};

// Start
window.onload = () => App.init();

</script>
</body>
</html>
