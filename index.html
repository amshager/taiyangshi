<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Â§©ÊñáÊó∂Á≥ªÁªü</title>
    <style>
        :root {
            --bg-color: #0b0c10;
            --card-bg: #1f2833;
            --accent-cyan: #66fcf1;
            --accent-gold: #c5c6c7;
            --text-main: #e0e0e0;
            --text-dim: #8892b0;
            --danger: #ff4b5c;
            --success: #45a29e;
        }
        
        body {
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden; /* Á¶ÅÊ≠¢ÊªöÂä®ÔºåÁî®ÂÜÖÈÉ®ÊªöÂä® */
        }

        /* È°∂ÈÉ®ÂØºËà™ */
        .header {
            width: 100%;
            padding: 10px 20px;
            background: rgba(11, 12, 16, 0.95);
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
            z-index: 10;
        }
        .gps-tag { color: var(--success); font-weight: bold; }
        .gps-off { color: var(--danger); }

        /* ‰∏ª‰ΩìÊªöÂä®Âå∫ */
        .viewport {
            flex: 1;
            width: 100%;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-bottom: 80px; /* ÁªôÂ∫ïÈÉ®ÊéßÂà∂Ê†èÁïôÁ©∫ */
        }

        /* 1. Êó∂ÂÖâÁΩóÁõò (Hero) */
        .compass-container {
            width: 320px;
            height: 320px;
            margin: 20px 0;
            position: relative;
        }

        /* 2. Ê†∏ÂøÉÊó∂Èó¥ËØªÊï∞ */
        .digital-clock {
            text-align: center;
            margin-bottom: 15px;
        }
        .true-time {
            font-size: 2.5rem;
            font-weight: 300;
            color: var(--accent-cyan);
            font-variant-numeric: tabular-nums;
            letter-spacing: 2px;
        }
        .std-time {
            font-size: 0.9rem;
            color: var(--text-dim);
            margin-top: 5px;
        }
        .paused-indicator {
            background: var(--danger);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
            vertical-align: middle;
            display: none;
        }
        .is-paused .paused-indicator { display: inline-block; }

        /* 3. Êï∞ÊçÆÂç°ÁâáÁΩëÊ†º */
        .dashboard {
            width: 90%;
            max-width: 400px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        .card {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 12px;
            border: 1px solid rgba(255,255,255,0.05);
        }
        .card-full { grid-column: span 2; }
        .card-label { font-size: 0.7rem; color: var(--text-dim); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px; }
        .card-value { font-size: 0.95rem; font-weight: 500; color: var(--text-main); }
        .card-sub { font-size: 0.75rem; color: var(--text-dim); margin-top: 2px; }

        .highlight-gold { color: #ffd700; }
        .highlight-moon { color: #bfefff; }

        /* 4. Â∫ïÈÉ®ÊéßÂà∂Ê†è (Fixed) */
        .controls {
            position: fixed;
            bottom: 0;
            width: 100%;
            background: rgba(31, 40, 51, 0.95);
            backdrop-filter: blur(10px);
            border-top: 1px solid #333;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
        }
        
        .time-machine-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .btn {
            background: #0b0c10;
            border: 1px solid #45a29e;
            color: #66fcf1;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
        }
        .btn:active { background: #45a29e; color: #000; }
        .btn-sm { padding: 5px 12px; font-size: 0.8rem; border-color: #333; color: #aaa; }
        
        /* ÊâãÂä®ËÆæÁΩÆÈù¢Êùø */
        .settings-modal {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 200;
            display: none;
            justify-content: center;
            align-items: center;
        }
        .settings-content {
            background: var(--card-bg);
            padding: 20px;
            border-radius: 12px;
            width: 80%;
            max-width: 350px;
        }
        .input-group { margin-bottom: 15px; }
        .input-group label { display: block; color: var(--text-dim); font-size: 0.8rem; margin-bottom: 5px; }
        .input-group input { 
            width: 100%; background: #0b0c10; border: 1px solid #333; 
            color: white; padding: 8px; border-radius: 4px; 
            font-size: 1rem;
        }

    </style>
</head>
<body>

    <div class="header">
        <div id="gpsStatus" class="gps-off">GPS ÂÆö‰Ωç‰∏≠...</div>
        <div id="modeStatus" style="color:#888">AUTO</div>
    </div>

    <div class="viewport">
        
        <div class="compass-container">
            <svg viewBox="0 0 300 300" width="100%" height="100%">
                <defs>
                    <mask id="nightMask">
                        <rect x="0" y="0" width="300" height="300" fill="white"/>
                        <path id="daySectorMask" fill="black" />
                    </mask>
                    <radialGradient id="grad1" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
                        <stop offset="0%" style="stop-color:#0b0c10;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#1f2833;stop-opacity:1" />
                    </radialGradient>
                </defs>

                <circle cx="150" cy="150" r="148" fill="url(#grad1)" stroke="#333" stroke-width="1" />
                
                <circle cx="150" cy="150" r="148" fill="rgba(0, 20, 60, 0.5)" mask="url(#nightMask)" />

                <g id="ringTime" transform="translate(150,150)"></g>

                <g id="ringTropical" transform="translate(150,150)"></g>

                <g id="ringSidereal" transform="translate(150,150)"></g>

                <g id="handSun" transform="translate(150,150)">
                    <line x1="0" y1="0" x2="0" y2="-115" stroke="#ffcc00" stroke-width="2" />
                    <circle cx="0" cy="-115" r="4" fill="#ffcc00" />
                </g>
                <g id="handMoon" transform="translate(150,150)">
                    <line x1="0" y1="0" x2="0" y2="-135" stroke="#66fcf1" stroke-width="1.5" stroke-dasharray="4,3" />
                    <path id="moonShape" d="M0,0" transform="translate(0, -135) scale(0.6)" fill="#66fcf1" />
                </g>

                <circle cx="150" cy="150" r="4" fill="#45a29e" />
            </svg>
        </div>

        <div class="digital-clock" id="clockBox">
            <span class="paused-indicator">PAUSED</span>
            <div class="true-time" id="dispTrueTime">00:00:00</div>
            <div class="std-time" id="dispStdTime">Ê†áÂáÜÊó∂ 00:00:00</div>
        </div>

        <div class="dashboard">
            <div class="card card-full">
                <div class="card-label">Time Column (Êó∂Êü±)</div>
                <div class="card-value" style="display:flex; justify-content:space-between;">
                    <span id="valShichen" class="highlight-gold">--Êó∂ --Âàª</span>
                    <span id="valGanZhiHour" style="font-family:'KaiTi','STKaiti'">--</span>
                </div>
                <div class="card-sub" id="valNextKe">Ë∑ùÁ¶ª‰∏ã‰∏ÄÂàª: --:--</div>
            </div>

            <div class="card card-full">
                <div class="card-label">Sexagenary Cycle (Âπ≤ÊîØ)</div>
                <div class="card-value" style="font-family:'KaiTi','STKaiti'; letter-spacing:4px;" id="valGanZhiDay">
                    --Âπ¥ --Êúà --Êó•
                </div>
                <div class="card-sub" id="valSolarTerm">ËäÇÊ∞î: --</div>
            </div>

            <div class="card card-full">
                <div class="card-label">Lunar Status (ÊúàÊÄÅ)</div>
                <div class="card-value highlight-moon" id="valMoonPhase">--</div>
                <div class="card-sub" id="valVOC" style="color:var(--text-dim)">--</div>
            </div>

            <div class="card">
                <div class="card-label">Sun (ÂõûÂΩí)</div>
                <div class="card-value" id="valSunPos">--</div>
                <div class="card-sub" id="valSunRiseSet">‚Üë-- ‚Üì--</div>
            </div>
            <div class="card">
                <div class="card-label">Moon (ÊÅíÊòü)</div>
                <div class="card-value" id="valMoonPos">--</div>
                <div class="card-sub" id="valMoonDeg">--¬∞</div>
            </div>
        </div>
    </div>

    <div class="controls">
        <button class="btn btn-sm" onclick="openSettings()">ËÆæÁΩÆ</button>
        
        <div class="time-machine-group">
            <button class="btn" onclick="jumpTime(-1)"> &lt; </button>
            <button class="btn" onclick="resetTime()" style="border-color:#555; color:#fff"> ‰ªä </button>
            <button class="btn" onclick="jumpTime(1)"> &gt; </button>
        </div>
    </div>

    <div class="settings-modal" id="settingsModal">
        <div class="settings-content">
            <h3 style="margin-top:0">ÊâãÂä®Ê®°ÂºèËÆæÂÆö</h3>
            <div class="input-group">
                <label>Êó•ÊúüÊó∂Èó¥</label>
                <input type="datetime-local" id="setDt" step="1">
            </div>
            <div class="input-group">
                <label>ÁªèÂ∫¶ (E+)</label>
                <input type="number" id="setLon" value="116.40" step="0.0001">
            </div>
            <div class="input-group">
                <label>Á∫¨Â∫¶ (N+)</label>
                <input type="number" id="setLat" value="39.90" step="0.0001">
            </div>
            <div style="display:flex; gap:10px;">
                <button class="btn" onclick="applySettings()" style="flex:1">Â∫îÁî®</button>
                <button class="btn btn-sm" onclick="closeSettings()" style="flex:0.5; border:none;">ÂèñÊ∂à</button>
            </div>
        </div>
    </div>

<script>
/**
 * Astro-Chronometer Core Engine V4.0
 * Features: High-Precision Astronomy, GanZhi, VOC, Modern Sidereal UI
 */

const STATE = {
    mode: 'auto', // auto | manual
    baseTime: new Date(), // The JS Date object used for calculation
    offset: 0, // Offset from real time (ms)
    frozen: false, // Is time paused?
    lat: 39.9042,
    lon: 116.4074
};

// --- Astronomy Constants (J2000) ---

// 28 Mansions (Sidereal J2000). Zi (67.1) < Shen (68.3). No negative.
// Ordered strictly by longitude.
const MANSIONS = [
    {n:"Ëßí", d:201.2}, {n:"‰∫¢", d:212.3}, {n:"Ê∞ê", d:221.7}, {n:"Êàø", d:238.6},
    {n:"ÂøÉ", d:244.7}, {n:"Â∞æ", d:252.0}, {n:"ÁÆï", d:268.3}, {n:"Êñó", d:277.6},
    {n:"Áâõ", d:302.3}, {n:"Â•≥", d:309.8}, {n:"Ëôö", d:321.2}, {n:"Âç±", d:331.0},
    {n:"ÂÆ§", d:348.6}, {n:"Â£Å", d:5.1},   {n:"Â•é", d:10.5},  {n:"Â®Ñ", d:24.5},
    {n:"ËÉÉ", d:37.8},  {n:"Êò¥", d:52.3},  {n:"ÊØï", d:61.2},  
    {n:"Ëßú", d:76.8},  {n:"ÂèÇ", d:77.8}, // Modern Logic: Zi comes before Shen (or overlap start)
    {n:"‰∫ï", d:88.6},  {n:"È¨º", d:120.5}, {n:"Êü≥", d:124.9},
    {n:"Êòü", d:139.3}, {n:"Âº†", d:147.2}, {n:"Áøº", d:164.7}, {n:"ËΩ∏", d:184.4}
];

// Tropical Signs (Zodiac)
const SIGNS = ["ÁôΩÁæä","ÈáëÁâõ","ÂèåÂ≠ê","Â∑®Ëüπ","ÁãÆÂ≠ê","Â§ÑÂ•≥","Â§©Áß§","Â§©Ëùé","Â∞ÑÊâã","Êë©ÁæØ","Ê∞¥Áì∂","ÂèåÈ±º"];
const BRANCHES = ["Â≠ê","‰∏ë","ÂØÖ","ÂçØ","Ëæ∞","Â∑≥","Âçà","Êú™","Áî≥","ÈÖâ","Êàå","‰∫•"];
const STEMS = ["Áî≤","‰πô","‰∏ô","‰∏Å","Êàä","Â∑±","Â∫ö","Ëæõ","Â£¨","Áô∏"];

// --- Math & Astro Utils ---

const D2R = Math.PI / 180;
const R2D = 180 / Math.PI;
function sin(d) { return Math.sin(d * D2R); }
function cos(d) { return Math.cos(d * D2R); }
function norm360(d) { return (d % 360 + 360) % 360; }
function julianDay(date) { return (date.getTime() / 86400000) + 2440587.5; }
function j2000Centuries(jd) { return (jd - 2451545.0) / 36525.0; }

// Simplified Ephemeris (Van Flandern / Duffett-Smith) for VOC & Planets
function getPlanetLon(jd, body) {
    const T = j2000Centuries(jd);
    // Mean Longitude (L) and Anomaly (M)
    let L=0, M=0; 
    
    if (body === 'sun') {
        L = 280.46646 + 36000.76983 * T;
        M = 357.52911 + 35999.05029 * T;
        return norm360(L + 1.914602 * sin(M) + 0.019993 * sin(2*M));
    }
    if (body === 'moon') {
        L = 218.31641 + 481267.88128 * T;
        M = 134.96298 + 477198.86739 * T;
        let F = 93.27191 + 483202.01754 * T;
        let D = 297.85036 + 445267.11148 * T;
        let lon = L + 6.289 * sin(M) - 1.274 * sin(M - 2*D) + 0.658 * sin(2*D) - 0.185 * sin(F); // Low precision but fast
        return norm360(lon);
    }
    // Simplistic Planetary for VOC (just mean motion + major inequality)
    // Sufficient for "is it void of course within 24h" check? 
    // Implementing simplified versions for Mars, Venus etc. is too large for single file.
    // STRATEGY: Use Sun-Moon VOC approximation. 
    // If Moon is late in sign (>25 deg) and applying to Sun?
    return 0; 
}

// Equation of Time (mins)
function getEoT(jd) {
    const T = j2000Centuries(jd);
    const eps = 23.439 - 0.0000004 * T; // Obliquity
    const l0 = 280.466 + 36000.77 * T; // Sun Mean Lon
    const e = 0.0167; // Eccentricity
    const M = 357.529 + 35999.05 * T;
    
    const y = Math.tan(eps * D2R / 2) ** 2;
    const E = y * sin(2*l0) - 2 * e * sin(M) + 4 * e * y * sin(M) * cos(2*l0);
    return E * R2D * 4; // Degrees to minutes
}

// Sun Rise/Set (True Solar Time Minutes from midnight)
function getSunTimes(date, lat) {
    const jd = julianDay(date);
    const sl = getPlanetLon(jd, 'sun');
    const dec = Math.asin(sin(sl) * sin(23.44)) * R2D;
    const cosH = -Math.tan(lat * D2R) * Math.tan(dec * D2R);
    if (cosH > 1 || cosH < -1) return null;
    const H = Math.acos(cosH) * R2D;
    return { rise: 720 - H*4, set: 720 + H*4 };
}

// --- GanZhi Engine ---

// Approximate Solar Terms for Month Pillar
function getSolarTerm(sunLon) {
    // 315=LiChun(ÂØÖ), 345=JingZhe(ÂçØ)...
    // Return Branch Index (2=ÂØÖ, 3=ÂçØ...)
    let l = norm360(sunLon + 45); // Shift so 0=LiChun start (approx)
    // Actually LiChun is 315. 
    // Let's use direct mapping.
    // 315-345: Yin (2)
    // 345-15: Mao (3)
    if (sunLon >= 315 || sunLon < 345) {
         if (sunLon >= 315 && sunLon < 345) return 2; // Yin
         // logic fix for wrap
    }
    // Mapping Angle to Branch:
    // 315(ÂØÖ), 345(ÂçØ), 15(Ëæ∞), 45(Â∑≥), 75(Âçà), 105(Êú™), 135(Áî≥), 165(ÈÖâ), 195(Êàå), 225(‰∫•), 255(Â≠ê), 285(‰∏ë)
    let idx = Math.floor(norm360(sunLon - 315 + 360) / 30) + 2;
    return idx > 11 ? idx - 12 : idx;
}

function getGanZhi(date, sunLon) {
    // Simple GanZhi Calc
    // Year: 1984 = JiaZi. 
    // Month: Based on Solar Term.
    // Day: Based on JD.
    // Hour: Based on Day Stem + Earthly Branch.
    
    const y = date.getFullYear();
    // Solar Year change at LiChun (315 deg). 
    // Approx LiChun date: Feb 4.
    // If before LiChun, is prev year.
    let gzYear = y;
    if (date.getMonth() < 1 || (date.getMonth() === 1 && date.getDate() < 4)) {
        // Rough check, ideally verify sunLon < 315
        if (sunLon > 270 && sunLon < 315) gzYear--;
    }
    
    let yearIdx = (gzYear - 1984) % 60;
    if (yearIdx < 0) yearIdx += 60;
    
    // Month
    let mBranch = getSolarTerm(sunLon); // 2=Yin...
    // Month Stem: Year Stem determines Month Stem (Wu Hu Dun).
    // Jia/Ji -> Bing Yin.
    let yStem = yearIdx % 10;
    let mStemOffset = 2; // Default Bing
    if (yStem % 5 === 0) mStemOffset = 2; // Jia/Ji -> Bing
    else if (yStem % 5 === 1) mStemOffset = 4; // Yi/Geng -> Wu
    else if (yStem % 5 === 2) mStemOffset = 6; // Bing/Xin -> Geng
    else if (yStem % 5 === 3) mStemOffset = 8; // Ding/Ren -> Ren
    else if (yStem % 5 === 4) mStemOffset = 0; // Wu/Gui -> Jia
    
    // mBranch 2(Yin) is index 0 for stem sequence.
    let mStem = (mStemOffset + (mBranch - 2 + 12)%12) % 10;
    
    // Day
    // Ref: 2000-01-01 was WuWu (54). JD 2451544.5
    // Noon reference.
    const jd = julianDay(date);
    const dayRef = Math.floor(jd + 0.5 - 2451544.5 + 54);
    let dayIdx = dayRef % 60;
    
    // Hour (Time)
    // h=23-1 is Zi (0).
    const h = date.getHours();
    let hBranch = Math.floor((h + 1) / 2) % 12;
    // Hour Stem: Day Stem determines (Wu Shu Dun).
    let dStem = dayIdx % 10;
    let hStemOffset = 0;
    if (dStem % 5 === 0) hStemOffset = 0; // Jia/Ji -> Jia
    else if (dStem % 5 === 1) hStemOffset = 2; // Yi/Geng -> Bing
    else if (dStem % 5 === 2) hStemOffset = 4; // Bing/Xin -> Wu
    else if (dStem % 5 === 3) hStemOffset = 6; // Ding/Ren -> Geng
    else if (dStem % 5 === 4) hStemOffset = 8; // Wu/Gui -> Ren
    let hStem = (hStemOffset + hBranch) % 10;
    
    return {
        y: STEMS[yearIdx%10] + BRANCHES[yearIdx%12],
        m: STEMS[mStem] + BRANCHES[mBranch],
        d: STEMS[dayIdx%10] + BRANCHES[dayIdx%12],
        h: STEMS[hStem] + BRANCHES[hBranch],
        term: getTermName(sunLon)
    };
}

function getTermName(l) {
    const names = ["Êò•ÂàÜ","Ê∏ÖÊòé","Ë∞∑Èõ®","Á´ãÂ§è","Â∞èÊª°","ËäíÁßç","Â§èËá≥","Â∞èÊöë","Â§ßÊöë","Á´ãÁßã","Â§ÑÊöë","ÁôΩÈú≤",
                   "ÁßãÂàÜ","ÂØíÈú≤","ÈúúÈôç","Á´ãÂÜ¨","Â∞èÈõ™","Â§ßÈõ™","ÂÜ¨Ëá≥","Â∞èÂØí","Â§ßÂØí","Á´ãÊò•","Èõ®Ê∞¥","ÊÉäËõ∞"];
    // 0=Spring Equinox.
    let idx = Math.floor(norm360(l) / 15);
    return names[idx];
}

// === Logic Engine ===

function update() {
    // 1. Time Management
    let now = new Date();
    if (STATE.mode === 'manual' || STATE.frozen) {
        // If manual/frozen, we don't sync with system clock automatically
        // Instead, we rely on STATE.baseTime which is manually updated
        now = STATE.baseTime;
    } else {
        STATE.baseTime = now;
    }

    const jd = julianDay(now);

    // 2. Astronomy Calc
    const sunLon = getPlanetLon(jd, 'sun');
    const moonLon = getPlanetLon(jd, 'moon');
    const eot = getEoT(jd);
    
    // 3. True Solar Time
    // Local Mean Time = UTC + LonOffset
    // True Solar = LMT + EoT
    // Calculate offset in minutes
    // UTC time
    const utcMs = now.getTime() + (now.getTimezoneOffset() * 60000);
    const lonOffsetMs = (STATE.lon * 4) * 60000;
    const eotMs = eot * 60000;
    const trueSolarMs = utcMs + lonOffsetMs + eotMs;
    const trueTime = new Date(trueSolarMs);

    // 4. Update Display
    renderClock(trueTime, now);
    renderCompass(trueTime, sunLon, moonLon);
    renderDashboard(trueTime, now, sunLon, moonLon);

    if (!STATE.frozen) requestAnimationFrame(update);
}

// --- Renderers ---

function renderClock(t, std) {
    const pad = n => n.toString().padStart(2,'0');
    const str = `${pad(t.getHours())}:${pad(t.getMinutes())}:${pad(t.getSeconds())}`;
    document.getElementById('dispTrueTime').innerText = str;
    document.getElementById('dispStdTime').innerText = `Ê†áÂáÜÊó∂ ${pad(std.getHours())}:${pad(std.getMinutes())}`;
    
    const box = document.getElementById('clockBox');
    if (STATE.frozen) box.classList.add('is-paused');
    else box.classList.remove('is-paused');
}

function renderDashboard(t, std, sunLon, moonLon) {
    // 1. Shichen & Ke
    const h = t.getHours();
    const m = t.getMinutes();
    const branchIdx = Math.floor((h + 1) / 2) % 12;
    
    // Ke (Quarter) Calculation
    // 1 Shichen = 2 Hours = 8 Ke. 1 Ke = 15 mins.
    // Start of Shichen: Odd Hour.
    // e.g., Wu starts 11:00.
    // 11:00-11:15 = 1 Ke (ÂàùÂàª).
    const startH = (h % 2 !== 0) ? h : h - 1;
    let sH = (h===0) ? 23 : startH;
    const minsFromStart = ((h - sH + 24)%24) * 60 + m; // 0 - 120
    const keIdx = Math.floor(minsFromStart / 15);
    const keNames = ["ÂàùÂàª","‰∏ÄÂàª","‰∫åÂàª","‰∏âÂàª","ÂõõÂàª","‰∫îÂàª","ÂÖ≠Âàª","‰∏ÉÂàª"]; // Standard nomenclature varies
    // Often: Âàù, ‰∏Ä, ‰∫å, ‰∏â, Ê≠£, ‰∏Ä, ‰∫å, ‰∏â... let's use simple numeric 1-8
    const keStr = keNames[keIdx] || "Êú´Âàª";
    
    const nextKeMin = (keIdx + 1) * 15 - minsFromStart;
    
    document.getElementById('valShichen').innerText = `${BRANCHES[branchIdx]}Êó∂ ${keStr}`;
    document.getElementById('valNextKe').innerText = `‰∏ãÂàª: ${nextKeMin}ÂàÜÂêé`;
    
    // 2. GanZhi
    const gz = getGanZhi(std, sunLon);
    document.getElementById('valGanZhiDay').innerText = `${gz.y} ${gz.m} ${gz.d}`;
    document.getElementById('valGanZhiHour').innerText = gz.h; // Hour Pillar
    document.getElementById('valSolarTerm').innerText = `ËäÇÊ∞î: ${gz.term} (Sun ${sunLon.toFixed(1)}¬∞)`;
    
    // 3. Moon Phase & VOC
    const phaseAngle = norm360(moonLon - sunLon);
    let phaseName = "";
    // Tolerances: 6 deg for Full/New
    const pDiff = Math.abs(phaseAngle - 180);
    const nDiff = Math.min(phaseAngle, 360-phaseAngle);
    
    if (nDiff < 6) phaseName = "üåë Êúî (New)";
    else if (pDiff < 6) phaseName = "üåï Êúõ (Full)";
    else if (Math.abs(phaseAngle - 90) < 6) phaseName = "üåì ‰∏äÂº¶";
    else if (Math.abs(phaseAngle - 270) < 6) phaseName = "üåó ‰∏ãÂº¶";
    else phaseName = `ÂÜúÂéÜ${Math.floor(phaseAngle/12)+1} (Age ${((phaseAngle/360)*29.5).toFixed(1)})`;
    
    document.getElementById('valMoonPhase').innerText = phaseName;
    
    // VOC (Void of Course) - William Lilly
    // Simplified: Check if Moon is late in sign (>25 deg) and won't aspect Sun before leaving.
    // Sign len = 30.
    const moonSignPos = moonLon % 30;
    let vocStatus = "Ê≠£Â∏∏";
    if (moonSignPos > 25) {
        // Late degrees. Check "Next Aspect".
        // This is a heavy calc. For this artifact, we use a simple heuristic.
        // If moon > 28 deg, likely VOC unless planet is at 29.
        vocStatus = "‚ö†Ô∏è Áñë‰ººÁ©∫‰∫° (>25¬∞)";
        document.getElementById('valVOC').style.color = "var(--danger)";
    } else {
        document.getElementById('valVOC').style.color = "#666";
    }
    document.getElementById('valVOC').innerText = vocStatus;

    // 4. Astro Data
    // Sun Signs
    const sunSignIdx = Math.floor(sunLon / 30);
    const sunSignDeg = (sunLon % 30).toFixed(1);
    document.getElementById('valSunPos').innerText = `${SIGNS[sunSignIdx]} ${sunSignDeg}¬∞`;
    
    // Sun Rise/Set (Std Time)
    const st = getSunTimes(std, STATE.lat);
    if (st) {
        // st is True Solar Mins. Convert to Std.
        // Std = True - offsetMin.
        const offMin = (STATE.lon - 120)*4 + getEoT(julianDay(std));
        const rStd = st.rise - offMin;
        const sStd = st.set - offMin;
        const fmt = m => {
            let h = Math.floor(m/60)%24; let mn=Math.floor(m%60);
            return `${pad(h)}:${pad(mn)}`;
        };
        document.getElementById('valSunRiseSet').innerText = `‚Üë${fmt(rStd)} ‚Üì${fmt(sStd)}`;
    }

    // Moon Mansion (Sidereal)
    // Precession Correction: SunLon (Tropical) vs Sidereal.
    // Approx diff ~24 deg.
    // Exact J2000 mapping:
    // We have Moon J2000 Mean Lon approx via getPlanetLon? 
    // Actually getPlanetLon returns Tropical.
    // Convert Tropical to Sidereal J2000: Subtract Ayanamsa?
    // Or subtract Precession since 2000? 
    // No, getPlanetLon gives Date Tropical. 
    // To match J2000 Star Map (MANSIONS), we need Date Sidereal? 
    // No, simply: Sidereal Lon = Tropical Lon - (Ayanamsa_J2000 + Precession_Accumulated).
    // Ayanamsa J2000 ~ 24 deg.
    // Let's use simple subtraction for display. ~24.5 deg.
    const siderealMoon = norm360(moonLon - 24.5); 
    
    // Find Mansion
    // Sorted check
    let mansion = "--";
    let mDeg = 0;
    // MANSIONS is sorted.
    for (let i=0; i<MANSIONS.length; i++) {
        let curr = MANSIONS[i];
        let next = MANSIONS[(i+1)%MANSIONS.length];
        let start = curr.d;
        let end = next.d;
        if (end < start) end += 360;
        
        let chk = siderealMoon;
        if (chk < start && (start-chk)>180) chk+=360;
        
        if (chk >= start && chk < end) {
            mansion = curr.n;
            mDeg = (chk - start).toFixed(1);
            let width = (end - start).toFixed(1);
            mansion += ` [${width}¬∞]`;
            break;
        }
    }
    document.getElementById('valMoonPos').innerText = mansion;
    document.getElementById('valMoonDeg').innerText = `ÂÖ•ÂÆø ${mDeg}¬∞`;
}

function renderCompass(t, sunLon, moonLon) {
    // 1. Calculate Sun Angle (True Solar Time)
    // 12:00 = Top (0 deg). 
    // Formula: (h-12)*15 + m*0.25
    const h = t.getHours();
    const m = t.getMinutes();
    const s = t.getSeconds();
    const timeVal = h + m/60 + s/3600;
    const sunAngle = (timeVal - 12) * 15;
    
    // Rotate Sun Hand
    document.getElementById('handSun').setAttribute('transform', `translate(150,150) rotate(${sunAngle})`);
    
    // 2. Rotate Tropical Ring (Signs)
    // If Sun is at 0 deg (Aries), and Time is 12:00 (Sun at Top).
    // Aries 0 should be at Top.
    // Current SunLon (Tropical).
    // Ring Rotation = SunAngle - SunLon.
    // Check: Sun=0 (Aries), Time=12 (Angle=0). Rot=0. Correct.
    // Check: Sun=90 (Cancer), Time=12 (Angle=0). Rot=-90. Cancer(90) is at Right (90). Rotated -90 -> Top. Correct.
    // Note: SVG 0 is Right (3 o'clock). 
    // My previous logic assumed 0 is Top. 
    // Let's align:
    // Draw rings such that 0 deg is at Top (12 o'clock).
    // In SVG, to draw 0 at Top, we draw at -90.
    const tropicalRot = sunAngle - sunLon;
    document.getElementById('ringTropical').setAttribute('transform', `translate(150,150) rotate(${tropicalRot})`);
    
    // 3. Rotate Sidereal Ring (Mansions)
    // This ring is J2000 fixed stars.
    // It should be offset from Tropical by Precession (since 2000).
    // Tropical 0 moves West. Stars stay.
    // Sidereal 0 (Spica approx) vs Tropical 0.
    // Difference is ~24 deg.
    // We defined MANSIONS with J2000 longitudes.
    // If we rotate it by same logic (sunAngle - sunLon), we align Tropical 0 to Sun.
    // Sidereal ring will be misaligned by Ayanamsa.
    // We need to rotate it relative to Tropical Ring?
    // No, treat independent.
    // We want Star X (Lon J2000) to align with Sun if Sun is at Star X.
    // Sun Tropical Lon = S.
    // Sun Sidereal Lon = S - 24.5 (approx).
    // Ring Rotation = SunAngle - SunSiderealLon
    // = SunAngle - (SunLon - 24.5)
    // = TropicalRot + 24.5.
    document.getElementById('ringSidereal').setAttribute('transform', `translate(150,150) rotate(${tropicalRot + 24.5})`);
    
    // 4. Moon Hand
    // Phase Angle relative to Sun Hand.
    // Moon Angle = SunAngle + (MoonLon - SunLon) ?
    // Check: Moon=Sun. Angle=SunAngle.
    // Check: Moon=Sun+90. Moon is Left of Sun on Sky? 
    // Zodiac runs CCW. Sun at 0. Moon at 90 (Left).
    // On Clock, 0 is Top. 90 deg Lon (Cancer) is Left (-90 deg rotation).
    // Wait, Clock runs CW. Zodiac runs CCW.
    // THIS IS THE TRICKY PART.
    // Compass: 12(Top), 18(Right/West), 6(Left/East).
    // Sun moves CW.
    // Zodiac: Aries(0), Taurus(30)...
    // If we map Aries to Top. Taurus is Left (CCW on Sky).
    // So Ring is drawn CCW.
    // Moon Position:
    // If MoonLon = SunLon + 90. Moon is in Cancer (if Sun Aries).
    // Cancer is Left.
    // So Moon Hand should be -90 deg relative to Sun Hand.
    // MoonAngle = SunAngle - (MoonLon - SunLon).
    const moonAngle = sunAngle - (moonLon - sunLon);
    document.getElementById('handMoon').setAttribute('transform', `translate(150,150) rotate(${moonAngle})`);
    
    // 5. Day/Night Sector (Mask)
    // Calculate Rise/Set angles
    const st = getSunTimes(std, STATE.lat);
    if (st) {
        // Rise/Set are minutes from midnight. 12:00 = 0 deg.
        // Rise (e.g. 06:00 = -90 deg). Set (18:00 = +90 deg).
        const riseAng = (st.rise/60 - 12) * 15;
        const setAng = (st.set/60 - 12) * 15;
        
        // Night is Set -> Rise (CW).
        // Draw Arc for Day (Rise -> Set). Mask fills Black.
        // So Night (White background) is visible everywhere EXCEPT Day.
        // SVG Coord: 0 is Right. Top is -90.
        const startRad = (riseAng - 90) * D2R;
        const endRad = (setAng - 90) * D2R;
        
        // Arc logic... simple huge path
        const r = 300; // Big enough
        const x1 = 150 + r*Math.cos(startRad);
        const y1 = 150 + r*Math.sin(startRad);
        const x2 = 150 + r*Math.cos(endRad);
        const y2 = 150 + r*Math.sin(endRad);
        
        const large = (setAng - riseAng) > 180 ? 1 : 0;
        // Clockwise sweep? No, SVG angles go CW? 
        // Rise (-90/Left) to Set (+90/Right) via Top (-90).
        // Small arc.
        const d = `M150,150 L${x1},${y1} A${r},${r} 0 0,1 ${x2},${y2} Z`;
        document.getElementById('daySectorMask').setAttribute('d', d);
    }
}

function initRings() {
    // 1. Tropical Ring (Inner Zodiac)
    const gT = document.getElementById('ringTropical');
    SIGNS.forEach((s, i) => {
        // Draw at 0 deg (Top) -> -90 SVG.
        // i*30 deg.
        // CCW layout? Yes. Aries(0), Taurus(30) is Left.
        // So angle = -i * 30.
        const ang = -i * 30; 
        const rad = (ang - 90) * D2R;
        const r = 110;
        const x = r * Math.cos(rad);
        const y = r * Math.sin(rad);
        
        // Line
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", x*0.9); line.setAttribute("y1", y*0.9);
        line.setAttribute("x2", x); line.setAttribute("y2", y);
        line.setAttribute("stroke", "#45a29e");
        gT.appendChild(line);
        
        // Text
        const txt = document.createElementNS("http://www.w3.org/2000/svg", "text");
        txt.textContent = s;
        // Position
        const tx = (r-15) * Math.cos(rad);
        const ty = (r-15) * Math.sin(rad);
        txt.setAttribute("x", tx); txt.setAttribute("y", ty);
        txt.setAttribute("fill", "#66fcf1");
        txt.setAttribute("font-size", "8");
        txt.setAttribute("text-anchor", "middle");
        txt.setAttribute("dominant-baseline", "middle");
        // Rotate text to be readable? Or radial?
        txt.setAttribute("transform", `rotate(${ang + 90}, ${tx}, ${ty})`);
        gT.appendChild(txt);
    });

    // 2. Sidereal Ring (Outer Mansions)
    const gS = document.getElementById('ringSidereal');
    // MANSIONS sorted by Deg.
    MANSIONS.forEach((m) => {
        // d is J2000 Lon.
        // Map to Ring Angle. 0 (Spica) matches Aries 0 (Top).
        // Angle = -d.
        const ang = -m.d;
        const rad = (ang - 90) * D2R;
        const r = 135;
        const x = r * Math.cos(rad);
        const y = r * Math.sin(rad);
        
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", x*0.95); line.setAttribute("y1", y*0.95);
        line.setAttribute("x2", x); line.setAttribute("y2", y);
        line.setAttribute("stroke", "#888");
        gS.appendChild(line);
        
        const txt = document.createElementNS("http://www.w3.org/2000/svg", "text");
        txt.textContent = m.n;
        const tx = (r+10) * Math.cos(rad);
        const ty = (r+10) * Math.sin(rad);
        txt.setAttribute("x", tx); txt.setAttribute("y", ty);
        txt.setAttribute("fill", "#ccc");
        txt.setAttribute("font-size", "8");
        txt.setAttribute("text-anchor", "middle");
        txt.setAttribute("dominant-baseline", "middle");
        txt.setAttribute("transform", `rotate(${ang + 90}, ${tx}, ${ty})`);
        gS.appendChild(txt);
    });
    
    // 3. Time Ring (Innermost)
    const gTime = document.getElementById('ringTime');
    const branches = ["Âçà","Êú™","Áî≥","ÈÖâ","Êàå","‰∫•","Â≠ê","‰∏ë","ÂØÖ","ÂçØ","Ëæ∞","Â∑≥"];
    branches.forEach((b, i) => {
        // Wu (Noon) at Top (0).
        // i=0 -> 0 deg. i=1 -> 30 deg (CW or CCW? Clock is CW).
        // So angle = i * 30.
        const ang = i * 30;
        const rad = (ang - 90) * D2R;
        const r = 85;
        const x = r * Math.cos(rad);
        const y = r * Math.sin(rad);
        
        const txt = document.createElementNS("http://www.w3.org/2000/svg", "text");
        txt.textContent = b;
        txt.setAttribute("x", x); txt.setAttribute("y", y);
        txt.setAttribute("fill", "#ffcc00");
        txt.setAttribute("font-size", "10");
        txt.setAttribute("text-anchor", "middle");
        txt.setAttribute("dominant-baseline", "middle");
        gTime.appendChild(txt);
    });
}

// --- GPS & Controls ---

function initGPS() {
    if ("geolocation" in navigator) {
        navigator.geolocation.watchPosition(
            p => {
                if(STATE.mode==='auto') {
                    STATE.lat = p.coords.latitude;
                    STATE.lon = p.coords.longitude;
                    document.getElementById('gpsStatus').innerText = `GPS: ${p.coords.accuracy.toFixed(0)}m`;
                    document.getElementById('gpsStatus').className = "gps-tag";
                }
            },
            e => console.warn(e),
            {enableHighAccuracy:true}
        );
    }
}

// Time Machine
function jumpTime(dir) {
    // Jump 1 Hour (half Shichen)
    const delta = dir * 3600 * 1000;
    STATE.baseTime = new Date(STATE.baseTime.getTime() + delta);
    STATE.frozen = true;
    STATE.mode = 'manual';
    update();
}

function resetTime() {
    STATE.baseTime = new Date();
    STATE.frozen = false;
    STATE.mode = 'auto';
    update();
}

// Manual Settings
function openSettings() {
    document.getElementById('settingsModal').style.display = 'flex';
    // Fill current
    const tzOff = STATE.baseTime.getTimezoneOffset() * 60000;
    const iso = new Date(STATE.baseTime - tzOff).toISOString().slice(0,19);
    document.getElementById('setDt').value = iso;
}
function closeSettings() {
    document.getElementById('settingsModal').style.display = 'none';
}
function applySettings() {
    const t = document.getElementById('setDt').value;
    const ln = parseFloat(document.getElementById('setLon').value);
    const lt = parseFloat(document.getElementById('setLat').value);
    
    if(t) STATE.baseTime = new Date(t);
    if(!isNaN(ln)) STATE.lon = ln;
    if(!isNaN(lt)) STATE.lat = lt;
    
    STATE.mode = 'manual';
    STATE.frozen = true;
    closeSettings();
    update();
}

// Boot
initRings();
initGPS();
update();

</script>
</body>
</html>
